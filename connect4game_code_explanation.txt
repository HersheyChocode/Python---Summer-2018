~ Player Inputs ~
We can start off by writing the first thing our program asks for; the name of the players. This is quite simple, as we just make two variables for the inputs. We convert this to a string just in case we need to add it to another string later on.


~ Game board ~
Now, thinking forward, we know that things repeat a lot. So, we can create functions instead of using a bunch of for loops. We can start by writing a function to make the game board. We can set its parameter to be  $\texttt{board}$ , for the board we will be using to make the gameboard. After, we can start by writing a variable for the numbers on top of the gameboard. This is just a simple string containing the numbers. Then, we can create an empty string for the game board. We can call it  $\texttt{gameBoard}$  As we keep adding to the string, it won't be empty. (Obviously  ;) ) Then, we can use a for loop to get each line in the board. Within this for loop we can use another for loop to get the character in each line. We can add this character to the empty string. After both of these for loops, we can modify  $\texttt{gameBoard}$  to be itself with the numbers on top of it. We can do this by adding the numbers before itself. Finally for this function, we can print and return our game board!


~ Player's turns ~
Now, we should think about another repeating occurrence. One of the most repeating is the process of asking the user for his/her turn. We can make two functions for the turns; one for player X, and one for player O.
~ Player X's turn ~
Let's start with player X: We can call the function  $\texttt{turnX}$ . we need a parameter  $\texttt{board}$  because we need to modify the board. Then, we can take the input of the column player X wants. We can create a variable for this, and make it an integer since we need to use it later on to modify the board. If it is out of range, we can let the player know. To do this, we can just use a simple while loop with the condition being if the input is less than  $0$  or greater than  $6$ . Inside the if loop, we can print a statement letting the player know they have entered an invalid response and need to enter a valid one. Then, we can take the input again. After this, we need to check if the bottom most character in the column is a dot. If it is, we can replace it with an X. If it is not, we go to the line above. To translate this into code, we can use a for loop first, going from  $5$  to  $-1$ , increments of  $-1$ . We make it go until  $-1$ , since python doesn't count the  $-1$ , it counts the number before it. We can represent it by  $\texttt{row}$ . Simply put, it's a for loop that goes from  $5$  to  $0$ . Underneath this for loop, we can use an if statement to determine whether it is a dot or not. However, there are two possibilities of having a dot; 1: if there is a new line before it, and 2: if there is not a new line before it. Just for less confusion, let us start with the no new line code. We first make an if loop. The condition is if the row'th row of the board, and the column chosen by the player is equal to a dot. As we learnt, in python, we represent it like this:
board[row][xColumn]=='. '
Then, under the if loop, we can use the left hand side of the condition, and make it equal to an "X" instead of a dot. Then, we return the board to exit the function. To make our other new line one, we can just copy and paste the if loop again. However, we need to make minor adjustments. The first one is that in the condition, our right handside is no longer a plain dot. We need to change it to have a newline before the dot. The other minor detail is that when we change it to equal X, it's not just X anymore; there is, again, a newline before the X. Then, with the same indentation as the for loop, we can return a string called  $\texttt{none}$ . The function returns none if there is no more space left inside the column.
~Player O's turn~
Now we can work on the playerO's turn's function. Instead of writing out the whole thing, we can just copy and paste the  $\texttt{turnX}$  and just change the "X's" to "O's". Working smart, not hard  :)  .


~ Winning Possibilities ~
Now we need to think about the future again - what steps will we have to repeat? Well we know that every time a player takes his/her turn, the program needs to check whether someone won. So, we can start to work on our possibilities.
~ Vertical Wins ~
One possibility of someone winning, is when there are 4 letters stacked on top of each other. Let's start writing our function for this. Well, we know that we need to get each column to see whether there are 4 X's in a row. In order to do that, we need two for loops - one for the rows, and one for the characters of each row. This may be a little confusing, so let's think a little more deep into this. For getting the first column, we need to get each rows first character. For getting the second column, we need to get each row's second character, and it repeats for each column. So we can start off by making the for loop for each character. We need this range to be 7, since we want it to run 6 times. Then, inside of this for loop, we can create an empty string for the column. We can call it  $\texttt{check}$ , since we are going to check it later on. As we progress, the string will be filled. Underneath this, we can create another for loop for each row. We want this range to be 6, since there are 5 rows. Inside of this for loop, we add our code to get each column. We need to add each row's character to the empty string. In python, we do it like this:
check = check + board[rows][char].strip('\n')
We can add the strip line so that it removes any new lines that are in the way. Then, after this for loop, we can add an if loop: The condition for this if loop is for whether our column has 4 "X's" in a row. Then, we want it to return "X". This will come in handy when we are printing our winning statement. After this if loop, we do the exact same thing except for if there are 4 O's in a row and it's an elif statement. We could copy paste or rewrite, since there's not much code anyways. After all the for loops and if loops, with the same indentation as our first line, we can return 'none', if nothing is possible.
~ Horizontal Wins ~
Now that our vertical function is done, we can work on our horizontal function! This one is a little easier, as we just need to check each row. So, as we said, we create our function with the board parameter, and create a for loop for each row in the board. Inside this for loop, we can create yet another empty string. Similar, right? We can call it  $\texttt{check}$ , since we are going to check whether it has four letters in a row or not. Then, underneath this, we can put a for loop for each character in the row. Inside this for loop, we just need to add the character to our empty string. Underneath this second for loop, we can add if statements which look exactly the same as our previous function. So guess what we get to do... Copy and paste! Yay! Again, after all the for and if loops, we can return "none" if there were no possibilities of winning.


~ Diagonal Wins ~
Now we get to a function that is slightly harder. It is to check whether someone can win diagonally. As you've probably realized, there are two diagonals, so we can start off by doing the one that leans to the left.
~ Left Diagonal Possibilities ~
By leaning to the left, I mean that the shape of a forward slash: / . The parameter being  $\texttt{board}$ . Let's think about this program: Let's say we start off by any dot in the middle, top: We need this function to check the row below, and the column to the left. Then we need it to check two rows below, and two columns to the left. Then three rows below, three columns left. Four rows below, four columns left. However, this is not the case for all dots: If we start off by using this method for the first dot in the first row, it won't work. The only way it will work is if we start off with the fourth dot in the first row. So we know we need two for loops so far: One for the rows, and one for the columns. Let's start off with a for loop for the rows. We need the range to be three, because we need three rows. In python, it would get the second row, since rows technically start at zero. However, it doesn't really matter for now. Then, inside this for loop, we need another for loop to get each column from the third column to the sixth. Keep in mind that when writing the range, we need it to be 3,7, not 3,6. Inside this for loop, we can again create the empty string, "check". Now let's think about what we are doing: As said before, we need the row after, and the column before; 2 rows after, 2 columns before, etc. It does seem a little repetitive though, correct? To make it a little more efficient, we can use another for loop. It can run until  $4$ , since the last step is to add 3 rows, and subtract 3 columns. We can represent the range by  $\texttt{nextIncrement}$ . We then can write our code for the steps. We need to add the r $\texttt{row+nextIncrement}$ , and the  $\texttt{column-nextIncrement}$  of our board to our empty string. Then, we can strip this of any new line so it is just dots or letters. Since python starts at 0, it will also count the first dot they are starting at, so we don't have to worry about that either! Underneath this current for loop, we can add the same if statements as before by... copying and pasting!
~ Right Diagonal Possibilities ~
Now onto the right diagonal function. This diagonal looks like a backslash: \ . Let's again think about this function: We know that to find this, we need to get the next row and the next column. However, if we start this in the very end, our function won't work. It will only work for the first three rows, and the first four columns. Now, let's start with our function. We define it and let it's parameter be the board. Then we have to make our for loop for the rows. The range is 3, because we need it to run 3 times. Then we need a for loop for the columns. The range for this is 4, since we need it to run 4 times. Pretty straightforward. Then, we, again, make the empty string. Underneath this, we can write another for loops for the increments as we did last time. Just a little refresher: This for loop is for the row and the column, next row, next column, second row, second column, etc. We use the for loop for the increments. Inside this for loop we write the code. We need to add the  $\texttt{row+nextIncrement}$ , and the  $\texttt{row+nextIncrement}$ of our board to our empty string. Then underneath the for loop we can copy paste the if loops. After all these for loops and if loops, we return " $\texttt{none}$ ". Now, we are done with all of our winning cases!


~ Game ~
Now that we are done with the cases, we can start writing the code for the actual game.
~ Game Board ~
We can create a board first. Our board is a 7 by 6 board. So, we can create 6 lists of of 7 dots. For each list, we should add a new line before the first dot. Then, we can transfer these lists into a list stored in a variable  $\texttt{board}$ . This variable is our board. Now we can make a gameboard out of this list. We just need to call our function. Our parameter is conveniently also called  $\texttt{board}$ .
~ Tie possibility ~
Now let's think ahead a little: We need to take the turn of each player until someone wins. To do this we can use a while loop. We use  $\texttt{while true}$  so that it repeats until the code is broken. Inside this while loop, we can write the code for our game. Since this loop keeps repeating, every time it repeats, we need to check whether the players tied. To do this, we need an if loop, whose condition is if a dot is not in the game board. Under this if loop, we print a statement that lets the players know that someone won. After, we break the code so that it doesn't keep asking for the players to take their turns.
~ Player X's turn ~
The next line of code we write is the code to take the turn player X's turn. We can simply do this by calling our function  $\texttt{turnX}$  and store this in a variable  $\texttt{board}$ . Since the function returns a board, we can store it in a variable. However, the function can also return  $\texttt{none}$ . The function returns none when there are no more possibilities in the column. We can write an if loop to notify the player that this has happened. Our condition is if our board is  $\texttt{none}$ . Inside this, we can write a simple print statement that tells the player it has happened, and that the turn will be handed over to the next player. After this if loop, we can create a variable for making a game board out of the board. Then, we can check if the player won in any way. We do this by calling each functions we wrote. We can store these in variables too.
~ Checking whether player X won ~
We can now write an if loop for whether one of those variable returned X. Our condition is a little long, but it is simple. We just say whether our variables is X. Underneath this if loop, we print a winning statement, and break the while loop.
~ Player O's turn ~
We can just copy and paste the code from player X's turn, and change any X's to O's. Again, working smart, not hard!
~ Checking whether player O won ~
Again, we can copy and paste the code from our player X's check, and change the X's to O's.  ;) 


So... after all this code, we can proudly say that... We. Are. DONE!  :D